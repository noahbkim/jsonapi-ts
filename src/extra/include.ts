import {AnyModel} from '../model';
import {ResourceMap} from './map';
import {OneReadDocument, PartialResourceQuery} from '../framework';
import {AnyIResource} from '../schema';

/** A concise map of relationships to include.
 *
 * This is typed specifically so that the include builder can reasonably check
 * types on the provided arguments.
 */
export type Include<TIResource extends AnyIResource> = {
  [K in keyof TIResource['relationships'] & string]: Array<string> | null;
};

/** Convert a map of relationships to a list of paths.
 *
 * Each value in the argument map should already be an array of strings or
 * null. If a value is null, we've already pushed the parent key as an entry.
 * If it's an array, also include each child, concatenated.
 *
 * include({
 *  name: null,
 *  friends: include({
 *    name: null
 *  }),
 * })
 *
 * will become
 *
 * include({
 *   name: null,
 *   friends: ["name"]
 * })
 *
 * will become
 *
 * ["name", "friends", "friends.name"]
 *
 * @param map
 */
export function include<TIResource extends AnyIResource>(map: Include<TIResource>): Array<string> {
  const result = [];
  for (const entry of Object.entries(map)) {
    result.push(entry[0]);
    if (entry[1] !== null) {
      for (const child of entry[1] as Array<string>) {
        result.push(`${entry[0]}.${child}`);
      }
    }
  }
  return result;
}

/** Interface for the relater builder object literal.
 *
 * This provides a convenient, minimal interface for generating new relaters.
 * Two members are required: the schema, which indicates which resources the
 * related expects to be included, and a relate method that binds the resources
 * to the corresponding relationships given a resource map.
 */
export interface RelaterBuilder<TIReadResource extends AnyIResource, TModel extends AnyModel<TIReadResource['type']>> {

  /** The map of root and nested fields the resultant relater expects.
   *
   * This is passed directly to the provided `include()` function, so refer to
   * the argument specifications in its documentation.
   */
  readonly schema: Include<TIReadResource>;

  /** Relate items referenced in the schema to a given model.
   *
   * Populate the relationships corresponding to the included items referenced
   * in the provided schema. This method doesn't return a model to reduce code
   * repetition; there is pretty much no scenario in which you want to replace
   * the model entirely.
   *
   * @param model the model to provide relationship data to.
   * @param map a resource map to draw included resources from.
   */
  relate(model: TModel, map: ResourceMap): void;
}

type Relate<TModel extends AnyModel> = (model: TModel, map: ResourceMap) => TModel;
type Map<TModel extends AnyModel> = (document: OneReadDocument<TModel>, model?: TModel) => TModel;

/** Generalized interface for relating models to included resources.
 *
 * We provide this contract as an interface to allow custom implementations for
 * more sophisticated use-cases. Generally, Relater's generated by the provided
 * `relater()` function are sufficient.
 */
export interface Relater<TModel extends AnyModel> {

  /** A flat list of related resources to request inclusion of. */
  readonly include: Array<string>;

  /** The core function that populates specified relationships. */
  readonly relate: Relate<TModel>;

  /** A wrapper around relate that supports document callback parameterization. */
  readonly map: Map<TModel>;

  /** Shorthand for a query builder that adds the specified include parameters. */
  readonly query: () => PartialResourceQuery<TModel['type']>;
}

/** Generate a new relater given a builder specification.
 *
 * @param builder a relater builder object from which to generate the relater.
 */
export function relater<TIReadResource extends AnyIResource, TModel extends AnyModel<TIReadResource['type']>>(
  builder: RelaterBuilder<TIReadResource, TModel>,
): Relater<TModel> {
  const i = include(builder.schema);
  return {
    include: i,

    // Relate, return
    relate: (model: TModel, map: ResourceMap) => {
      builder.relate(model, map);
      return model;
    },

    // Create the map from the document, relate, return
    map: (document: OneReadDocument<TModel>, model?: TModel) => {
      model = model ?? document.data!;
      const map = new ResourceMap().putAll(document.included);
      builder.relate(model, map);
      return model;
    },

    // Only add the include parameter
    query: () => {
      return new PartialResourceQuery().include(...i);
    },
  };
}
